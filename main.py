# =========================================================
# üß† PROYECTO: Generador de desaf√≠os diarios con IA (Groq API)
# =========================================================
# - Historial JSON con escritura at√≥mica y backup si se corrompe
# - Parser JSON robusto para respuestas con ruido
# - Deduplicaci√≥n de desaf√≠os recientes por categor√≠a
# - Env√≠o a Telegram con logs
# =========================================================

from groq import Groq
from telegram import Bot
from datetime import datetime
from pathlib import Path
import os
import time
import json
import re
import tempfile
import shutil
import sys

# =========================================================
# üîß CONFIGURACI√ìN
# =========================================================

GROQ_API_KEY = os.getenv("GROQ_API_KEY")
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")

# Puedes sobreescribir la ruta del historial con env var HIST_PATH
# Ej: HIST_PATH=".data/historial_desafios.json"
HIST_PATH = Path(os.getenv("HIST_PATH", "historial_desafios.json"))

# Par√°metros de operaci√≥n
MAX_REINTENTOS = int(os.getenv("MAX_REINTENTOS", "5"))   # reintentos del LLM
MAX_DIAS_HIST = int(os.getenv("MAX_DIAS_HIST", "30"))    # d√≠as a mantener en historial
PAUSA_ENTRE_MENSAJES = float(os.getenv("PAUSA_SEG", "2"))  # segundos entre mensajes Telegram

# Modo seco: no env√≠a a Telegram ni llama a Groq (para pruebas locales)
DRY_RUN = os.getenv("DRY_RUN", "0") == "1"

# =========================================================
# ‚úÖ VALIDACIONES B√ÅSICAS
# =========================================================

if not DRY_RUN:
    if not GROQ_API_KEY:
        raise RuntimeError("‚ùå Falta GROQ_API_KEY en variables de entorno.")
    if not TELEGRAM_TOKEN or not TELEGRAM_CHAT_ID:
        raise RuntimeError("‚ùå Falta TELEGRAM_TOKEN o TELEGRAM_CHAT_ID en variables de entorno.")

# =========================================================
# üöÄ CLIENTES
# =========================================================

client = Groq(api_key=GROQ_API_KEY) if not DRY_RUN else None
bot = Bot(token=TELEGRAM_TOKEN) if not DRY_RUN else None

# =========================================================
# üß© UTILIDADES DE HISTORIAL (robustas y at√≥micas)
# =========================================================

def _escritura_atomica_json(path: Path, data: dict):
    """
    Escribe JSON de forma at√≥mica:
    1) escribe en un archivo temporal
    2) fsync
    3) replace al destino
    """
    path.parent.mkdir(parents=True, exist_ok=True)
    print(f"üìù Guardando historial en: {path.resolve()}")
    with tempfile.NamedTemporaryFile("w", delete=False, encoding="utf-8") as tmp:
        json.dump(data, tmp, ensure_ascii=False, indent=2)
        tmp.flush()
        os.fsync(tmp.fileno())
        tmp_name = tmp.name
    os.replace(tmp_name, path)
    print(f"‚úÖ Historial escrito. Tama√±o: {path.stat().st_size} bytes")

def _backup_si_corrupto(path: Path):
    """
    Si el JSON existe pero es inv√°lido, lo renombramos como .bak con timestamp
    para no perderlo y arrancar limpio.
    """
    if path.exists():
        ts = datetime.now().strftime("%Y%m%d-%H%M%S")
        bak = path.with_suffix(path.suffix + f".{ts}.bak")
        try:
            shutil.copy2(path, bak)
            print(f"‚ö†Ô∏è Historial inv√°lido. Backup creado: {bak}")
        except Exception as e:
            print(f"‚ö†Ô∏è No se pudo crear backup del historial: {e}")

def cargar_historial() -> dict:
    """
    Carga un dict { 'YYYY-MM-DD': {...desafios...}, ... }
    Si el archivo no existe o est√° vac√≠o, devuelve {}.
    Si est√° corrupto, hace backup y devuelve {}.
    """
    if not HIST_PATH.exists():
        print(f"‚ÑπÔ∏è No existe historial a√∫n en {HIST_PATH.resolve()}")
        return {}
    try:
        texto = HIST_PATH.read_text(encoding="utf-8").strip()
        if not texto:
            print("‚ÑπÔ∏è Historial vac√≠o, devolviendo {}")
            return {}
        data = json.loads(texto)
        if not isinstance(data, dict):
            _backup_si_corrupto(HIST_PATH)
            return {}
        return data
    except json.JSONDecodeError:
        _backup_si_corrupto(HIST_PATH)
        return {}
    except Exception as e:
        print(f"‚ö†Ô∏è Error leyendo historial: {e}")
        return {}

def _ordenar_y_recortar(historial: dict, max_dias: int = MAX_DIAS_HIST) -> dict:
    """
    Mantiene solo las √∫ltimas 'max_dias' fechas (ordenadas por fecha asc).
    """
    fechas = sorted(k for k in historial.keys() if re.fullmatch(r"\d{4}-\d{2}-\d{2}", k))
    if len(fechas) > max_dias:
        fechas = fechas[-max_dias:]
    return {k: historial[k] for k in fechas}

def guardar_historial(fecha: str, desafios: dict):
    """
    Guarda (o reemplaza) la entrada de una 'fecha' con escritura at√≥mica, y
    conserva solo MAX_DIAS_HIST d√≠as. Verifica post-escritura.
    """
    try:
        historial = cargar_historial()
        historial[fecha] = desafios
        historial = _ordenar_y_recortar(historial, MAX_DIAS_HIST)
        _escritura_atomica_json(HIST_PATH, historial)

        # Verificaci√≥n inmediata
        verif = cargar_historial()
        if fecha in verif:
            print(f"üîé Verificado: {fecha} presente en historial ({len(verif)} d√≠as guardados).")
        else:
            print("‚ùå Verificaci√≥n fall√≥: fecha no encontrada tras guardar.")
    except Exception as e:
        print(f"‚ùå No se pudo guardar historial: {e}")

def obtener_desafios_recientes(dias: int = 5) -> dict:
    """
    Devuelve sets con textos recientes por categor√≠a para evitar repeticiones.
    Estructura: {"CrossFit": set(), "Alimentaci√≥n": set(), "Bienestar": set()}
    Ignora fechas con estructura inesperada.
    """
    historial = cargar_historial()
    # ordenamos y quedamos con los √∫ltimos N
    ordenado = _ordenar_y_recortar(historial, max_dias=max(len(historial), dias) or dias)
    ultimos_items = list(ordenado.items())[-dias:]

    recientes = {"CrossFit": set(), "Alimentaci√≥n": set(), "Bienestar": set()}
    for _, dia in ultimos_items:
        if not isinstance(dia, dict):
            continue
        for cat in recientes.keys():
            if cat in dia and isinstance(dia[cat], str):
                recientes[cat].add(dia[cat])
    print(f"üßæ Desaf√≠os recientes para evitar repeticiones: { {k: len(v) for k,v in recientes.items()} }")
    return recientes

# =========================================================
# üß† UTILIDAD PARA EXTRAER JSON ROBUSTO
# =========================================================

def extraer_json_robusto(texto: str):
    """
    Intenta extraer el primer objeto JSON '{}' del texto.
    - Intento directo
    - Normaliza comillas simples ‚Üí dobles cuando parece JSON malformado.
    - Extrae el primer bloque {...} con DOTALL.
    - Repara escapes rotos m√≠nimos y reintenta.
    """
    if not texto:
        return None

    # 1) Intento directo por si viene limpio
    try:
        return json.loads(texto)
    except Exception:
        pass

    # 2) Normalizar comillas simples ‚Üí dobles (tolerante)
    texto_corr = re.sub(r"'", '"', texto)

    # 3) Tomar el primer dict que parezca JSON con DOTALL
    m = re.search(r"\{.*\}", texto_corr, flags=re.DOTALL)
    if not m:
        return None

    candidato = m.group(0)

    # 4) Quitar secuencias de escape rotas tipo \X no est√°ndar
    candidato = re.sub(r'\\(?![\\/"bfnrt])', r'\\\\', candidato)

    # 5) Reintento final
    try:
        return json.loads(candidato)
    except Exception:
        # Limpieza m√≠nima extra: compactar espacios
        candidato2 = re.sub(r"\s+", " ", candidato)
        try:
            return json.loads(candidato2)
        except Exception:
            return None

# =========================================================
# üß† GENERADOR DE DESAF√çOS (Groq)
# =========================================================

def generar_desafio_por_categoria(prompt: str, recientes: dict) -> dict:
    if DRY_RUN:
        # Modo pruebas sin Groq
        print("üî¨ DRY_RUN=1 ‚Üí devolviendo desaf√≠os dummy")
        return {
            "CrossFit": "5 series de 10 burpees con 60s de descanso.",
            "Alimentaci√≥n": "Incluye 2 porciones de verduras de hoja verde en el almuerzo.",
            "Bienestar": "10 minutos de respiraci√≥n diafragm√°tica antes de dormir."
        }

    for intento in range(1, MAX_REINTENTOS + 1):
        try:
            response = client.chat.completions.create(
                model="llama-3.1-8b-instant",
                messages=[
                    {"role": "system",
                     "content": (
                         "Eres un especialista en rendimiento humano, nutrici√≥n y fisiolog√≠a. "
                         "Devuelve √∫nicamente JSON v√°lido con claves exactamente: "
                         '"CrossFit", "Alimentaci√≥n", "Bienestar".'
                     )},
                    {"role": "user", "content": prompt},
                ],
                temperature=0.4,
                max_tokens=300,
            )

            contenido = (response.choices[0].message.content or "").strip()
            print(f"üß© Respuesta LLM (recortada 200 chars): {contenido[:200]}{'...' if len(contenido)>200 else ''}")
            desafios = extraer_json_robusto(contenido)
            if not (isinstance(desafios, dict) and
                    all(k in desafios for k in ("CrossFit", "Alimentaci√≥n", "Bienestar")) and
                    all(isinstance(desafios[k], str) for k in desafios)):
                print(f"‚ö†Ô∏è Intento {intento}: No se detect√≥ JSON v√°lido con estructura esperada")
                continue

            # Evitar repetir desaf√≠os recientes
            for cat in ("CrossFit", "Alimentaci√≥n", "Bienestar"):
                if desafios[cat] in recientes.get(cat, set()):
                    desafios[cat] = f"{desafios[cat]} (variante {intento})"

            return desafios

        except Exception as e:
            print(f"‚ö†Ô∏è Intento {intento}: Error generando desaf√≠o: {e}")

    return {"Error": "No se pudo generar JSON v√°lido tras varios intentos"}

def generar_desafios_diarios() -> dict:
    recientes = obtener_desafios_recientes()
    prompt = (
        "Genera tres desaf√≠os diarios distintos y concisos en espa√±ol: "
        "CrossFit, Alimentaci√≥n y Bienestar. "
        f"Evita repetir estos desaf√≠os recientes (texto exacto): {recientes}. "
        "Cada desaf√≠o debe ser UNA sola frase breve, clara, basada en evidencia y pragm√°tica. "
        "Devuelve √∫nicamente un JSON con la estructura exacta: "
        '{"CrossFit": "texto", "Alimentaci√≥n": "texto", "Bienestar": "texto"} '
        "Sin listas, sin comentarios, sin texto extra."
    )
    return generar_desafio_por_categoria(prompt, recientes)

# =========================================================
# ‚úâÔ∏è ENV√çO A TELEGRAM
# =========================================================

def enviar_a_telegram(mensaje: str):
    timestamp = datetime.now().strftime('%H:%M:%S')
    body = f"‚è∞ {timestamp}\n{mensaje}"
    if DRY_RUN:
        print(f"[DRY_RUN] {body}")
        return
    bot.send_message(chat_id=TELEGRAM_CHAT_ID, text=body)
    print(body)

# =========================================================
# üîÅ CICLO PRINCIPAL
# =========================================================

def ejecutar_ciclo_desafios():
    fecha = datetime.now().strftime("%Y-%m-%d")
    print(f"üìÖ Fecha de hoy: {fecha}")
    print(f"üìÇ Working dir: {os.getcwd()}")
    print(f"üóÇ Archivo historial: {HIST_PATH.resolve()}")

    desafios = generar_desafios_diarios()

    if "Error" in desafios:
        enviar_a_telegram(f"‚ö†Ô∏è Error generando desaf√≠os: {desafios['Error']}")
        guardar_historial(fecha, {"Error": desafios["Error"]})
        return

    header = f"üß≠ Desaf√≠os del d√≠a ‚Äî {fecha}"
    enviar_a_telegram(header)

    for categoria, contenido in desafios.items():
        mensaje = f"üìò {categoria}:\n{contenido}"
        enviar_a_telegram(mensaje)
        time.sleep(PAUSA_ENTRE_MENSAJES)

    # Guardado robusto y verificado
    guardar_historial(fecha, desafios)

# =========================================================
# üß™ PRUEBA R√ÅPIDA DEL HISTORIAL (opcional)
# =========================================================

def prueba_historial_minima():
    print("=== PRUEBA HISTORIAL ===")
    fecha = datetime.now().strftime("%Y-%m-%d")
    dummy = {"CrossFit": "Test CF", "Alimentaci√≥n": "Test Ali", "Bienestar": "Test Bien"}
    guardar_historial(fecha, dummy)
    data = cargar_historial()
    print(f"üì¶ Claves del historial (√∫ltimas 3): {list(data.keys())[-3:]}")
    print(f"üìÑ Ubicaci√≥n: {HIST_PATH.resolve()}")
    print("=== FIN PRUEBA ===")

# =========================================================
# üèÅ EJECUCI√ìN
# =========================================================

if __name__ == "__main__":
    print("üß† Iniciando ciclo de desaf√≠os diarios...")
    # Activa esta l√≠nea una sola vez si quieres validar guardado sin Groq/Telegram:
    # os.environ["DRY_RUN"] = "1"; DRY_RUN = True; prueba_historial_minima()
    try:
        ejecutar_ciclo_desafios()
        print("‚úÖ Env√≠o completado.")
    except Exception as e:
        print(f"üí• Error en ejecuci√≥n principal: {e}")
        # En caso de error, deja una marca en el historial para diagn√≥stico
        fecha = datetime.now().strftime("%Y-%m-%d")
        try:
            guardar_historial(fecha, {"Error": f"MainException: {e}"})
        except Exception as e2:
            print(f"üí• Error adicional guardando historial tras excepci√≥n: {e2}")
        sys.exit(1)
